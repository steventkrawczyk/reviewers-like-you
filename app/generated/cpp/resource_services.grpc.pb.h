// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: resource_services.proto
#ifndef GRPC_resource_5fservices_2eproto__INCLUDED
#define GRPC_resource_5fservices_2eproto__INCLUDED

#include "resource_services.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace proto {

class MainDatastoreService final {
 public:
  static constexpr char const* service_full_name() {
    return "proto.MainDatastoreService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status UploadReview(::grpc::ClientContext* context, const ::proto::UploadReviewRequest& request, ::proto::Payload* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>> AsyncUploadReview(::grpc::ClientContext* context, const ::proto::UploadReviewRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>>(AsyncUploadReviewRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>> PrepareAsyncUploadReview(::grpc::ClientContext* context, const ::proto::UploadReviewRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>>(PrepareAsyncUploadReviewRaw(context, request, cq));
    }
    virtual ::grpc::Status BatchUploadReview(::grpc::ClientContext* context, const ::proto::BatchUploadReviewRequest& request, ::proto::Payload* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>> AsyncBatchUploadReview(::grpc::ClientContext* context, const ::proto::BatchUploadReviewRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>>(AsyncBatchUploadReviewRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>> PrepareAsyncBatchUploadReview(::grpc::ClientContext* context, const ::proto::BatchUploadReviewRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>>(PrepareAsyncBatchUploadReviewRaw(context, request, cq));
    }
    virtual ::grpc::Status GetReviewsByAuthor(::grpc::ClientContext* context, const ::proto::GetReviewsByAuthorRequest& request, ::proto::GetReviewsByAuthorResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::GetReviewsByAuthorResponse>> AsyncGetReviewsByAuthor(::grpc::ClientContext* context, const ::proto::GetReviewsByAuthorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::GetReviewsByAuthorResponse>>(AsyncGetReviewsByAuthorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::GetReviewsByAuthorResponse>> PrepareAsyncGetReviewsByAuthor(::grpc::ClientContext* context, const ::proto::GetReviewsByAuthorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::GetReviewsByAuthorResponse>>(PrepareAsyncGetReviewsByAuthorRaw(context, request, cq));
    }
    virtual ::grpc::Status GetAuthors(::grpc::ClientContext* context, const ::proto::GetAuthorsRequest& request, ::proto::GetAuthorsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::GetAuthorsResponse>> AsyncGetAuthors(::grpc::ClientContext* context, const ::proto::GetAuthorsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::GetAuthorsResponse>>(AsyncGetAuthorsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::GetAuthorsResponse>> PrepareAsyncGetAuthors(::grpc::ClientContext* context, const ::proto::GetAuthorsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::GetAuthorsResponse>>(PrepareAsyncGetAuthorsRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void UploadReview(::grpc::ClientContext* context, const ::proto::UploadReviewRequest* request, ::proto::Payload* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UploadReview(::grpc::ClientContext* context, const ::proto::UploadReviewRequest* request, ::proto::Payload* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void BatchUploadReview(::grpc::ClientContext* context, const ::proto::BatchUploadReviewRequest* request, ::proto::Payload* response, std::function<void(::grpc::Status)>) = 0;
      virtual void BatchUploadReview(::grpc::ClientContext* context, const ::proto::BatchUploadReviewRequest* request, ::proto::Payload* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetReviewsByAuthor(::grpc::ClientContext* context, const ::proto::GetReviewsByAuthorRequest* request, ::proto::GetReviewsByAuthorResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetReviewsByAuthor(::grpc::ClientContext* context, const ::proto::GetReviewsByAuthorRequest* request, ::proto::GetReviewsByAuthorResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetAuthors(::grpc::ClientContext* context, const ::proto::GetAuthorsRequest* request, ::proto::GetAuthorsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetAuthors(::grpc::ClientContext* context, const ::proto::GetAuthorsRequest* request, ::proto::GetAuthorsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>* AsyncUploadReviewRaw(::grpc::ClientContext* context, const ::proto::UploadReviewRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>* PrepareAsyncUploadReviewRaw(::grpc::ClientContext* context, const ::proto::UploadReviewRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>* AsyncBatchUploadReviewRaw(::grpc::ClientContext* context, const ::proto::BatchUploadReviewRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>* PrepareAsyncBatchUploadReviewRaw(::grpc::ClientContext* context, const ::proto::BatchUploadReviewRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::GetReviewsByAuthorResponse>* AsyncGetReviewsByAuthorRaw(::grpc::ClientContext* context, const ::proto::GetReviewsByAuthorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::GetReviewsByAuthorResponse>* PrepareAsyncGetReviewsByAuthorRaw(::grpc::ClientContext* context, const ::proto::GetReviewsByAuthorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::GetAuthorsResponse>* AsyncGetAuthorsRaw(::grpc::ClientContext* context, const ::proto::GetAuthorsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::GetAuthorsResponse>* PrepareAsyncGetAuthorsRaw(::grpc::ClientContext* context, const ::proto::GetAuthorsRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status UploadReview(::grpc::ClientContext* context, const ::proto::UploadReviewRequest& request, ::proto::Payload* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>> AsyncUploadReview(::grpc::ClientContext* context, const ::proto::UploadReviewRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>>(AsyncUploadReviewRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>> PrepareAsyncUploadReview(::grpc::ClientContext* context, const ::proto::UploadReviewRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>>(PrepareAsyncUploadReviewRaw(context, request, cq));
    }
    ::grpc::Status BatchUploadReview(::grpc::ClientContext* context, const ::proto::BatchUploadReviewRequest& request, ::proto::Payload* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>> AsyncBatchUploadReview(::grpc::ClientContext* context, const ::proto::BatchUploadReviewRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>>(AsyncBatchUploadReviewRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>> PrepareAsyncBatchUploadReview(::grpc::ClientContext* context, const ::proto::BatchUploadReviewRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>>(PrepareAsyncBatchUploadReviewRaw(context, request, cq));
    }
    ::grpc::Status GetReviewsByAuthor(::grpc::ClientContext* context, const ::proto::GetReviewsByAuthorRequest& request, ::proto::GetReviewsByAuthorResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::GetReviewsByAuthorResponse>> AsyncGetReviewsByAuthor(::grpc::ClientContext* context, const ::proto::GetReviewsByAuthorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::GetReviewsByAuthorResponse>>(AsyncGetReviewsByAuthorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::GetReviewsByAuthorResponse>> PrepareAsyncGetReviewsByAuthor(::grpc::ClientContext* context, const ::proto::GetReviewsByAuthorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::GetReviewsByAuthorResponse>>(PrepareAsyncGetReviewsByAuthorRaw(context, request, cq));
    }
    ::grpc::Status GetAuthors(::grpc::ClientContext* context, const ::proto::GetAuthorsRequest& request, ::proto::GetAuthorsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::GetAuthorsResponse>> AsyncGetAuthors(::grpc::ClientContext* context, const ::proto::GetAuthorsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::GetAuthorsResponse>>(AsyncGetAuthorsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::GetAuthorsResponse>> PrepareAsyncGetAuthors(::grpc::ClientContext* context, const ::proto::GetAuthorsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::GetAuthorsResponse>>(PrepareAsyncGetAuthorsRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void UploadReview(::grpc::ClientContext* context, const ::proto::UploadReviewRequest* request, ::proto::Payload* response, std::function<void(::grpc::Status)>) override;
      void UploadReview(::grpc::ClientContext* context, const ::proto::UploadReviewRequest* request, ::proto::Payload* response, ::grpc::ClientUnaryReactor* reactor) override;
      void BatchUploadReview(::grpc::ClientContext* context, const ::proto::BatchUploadReviewRequest* request, ::proto::Payload* response, std::function<void(::grpc::Status)>) override;
      void BatchUploadReview(::grpc::ClientContext* context, const ::proto::BatchUploadReviewRequest* request, ::proto::Payload* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetReviewsByAuthor(::grpc::ClientContext* context, const ::proto::GetReviewsByAuthorRequest* request, ::proto::GetReviewsByAuthorResponse* response, std::function<void(::grpc::Status)>) override;
      void GetReviewsByAuthor(::grpc::ClientContext* context, const ::proto::GetReviewsByAuthorRequest* request, ::proto::GetReviewsByAuthorResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetAuthors(::grpc::ClientContext* context, const ::proto::GetAuthorsRequest* request, ::proto::GetAuthorsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetAuthors(::grpc::ClientContext* context, const ::proto::GetAuthorsRequest* request, ::proto::GetAuthorsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::proto::Payload>* AsyncUploadReviewRaw(::grpc::ClientContext* context, const ::proto::UploadReviewRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::Payload>* PrepareAsyncUploadReviewRaw(::grpc::ClientContext* context, const ::proto::UploadReviewRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::Payload>* AsyncBatchUploadReviewRaw(::grpc::ClientContext* context, const ::proto::BatchUploadReviewRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::Payload>* PrepareAsyncBatchUploadReviewRaw(::grpc::ClientContext* context, const ::proto::BatchUploadReviewRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::GetReviewsByAuthorResponse>* AsyncGetReviewsByAuthorRaw(::grpc::ClientContext* context, const ::proto::GetReviewsByAuthorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::GetReviewsByAuthorResponse>* PrepareAsyncGetReviewsByAuthorRaw(::grpc::ClientContext* context, const ::proto::GetReviewsByAuthorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::GetAuthorsResponse>* AsyncGetAuthorsRaw(::grpc::ClientContext* context, const ::proto::GetAuthorsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::GetAuthorsResponse>* PrepareAsyncGetAuthorsRaw(::grpc::ClientContext* context, const ::proto::GetAuthorsRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_UploadReview_;
    const ::grpc::internal::RpcMethod rpcmethod_BatchUploadReview_;
    const ::grpc::internal::RpcMethod rpcmethod_GetReviewsByAuthor_;
    const ::grpc::internal::RpcMethod rpcmethod_GetAuthors_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status UploadReview(::grpc::ServerContext* context, const ::proto::UploadReviewRequest* request, ::proto::Payload* response);
    virtual ::grpc::Status BatchUploadReview(::grpc::ServerContext* context, const ::proto::BatchUploadReviewRequest* request, ::proto::Payload* response);
    virtual ::grpc::Status GetReviewsByAuthor(::grpc::ServerContext* context, const ::proto::GetReviewsByAuthorRequest* request, ::proto::GetReviewsByAuthorResponse* response);
    virtual ::grpc::Status GetAuthors(::grpc::ServerContext* context, const ::proto::GetAuthorsRequest* request, ::proto::GetAuthorsResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_UploadReview : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UploadReview() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_UploadReview() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadReview(::grpc::ServerContext* /*context*/, const ::proto::UploadReviewRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUploadReview(::grpc::ServerContext* context, ::proto::UploadReviewRequest* request, ::grpc::ServerAsyncResponseWriter< ::proto::Payload>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_BatchUploadReview : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_BatchUploadReview() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_BatchUploadReview() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchUploadReview(::grpc::ServerContext* /*context*/, const ::proto::BatchUploadReviewRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBatchUploadReview(::grpc::ServerContext* context, ::proto::BatchUploadReviewRequest* request, ::grpc::ServerAsyncResponseWriter< ::proto::Payload>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetReviewsByAuthor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetReviewsByAuthor() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_GetReviewsByAuthor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetReviewsByAuthor(::grpc::ServerContext* /*context*/, const ::proto::GetReviewsByAuthorRequest* /*request*/, ::proto::GetReviewsByAuthorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetReviewsByAuthor(::grpc::ServerContext* context, ::proto::GetReviewsByAuthorRequest* request, ::grpc::ServerAsyncResponseWriter< ::proto::GetReviewsByAuthorResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetAuthors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetAuthors() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetAuthors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAuthors(::grpc::ServerContext* /*context*/, const ::proto::GetAuthorsRequest* /*request*/, ::proto::GetAuthorsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAuthors(::grpc::ServerContext* context, ::proto::GetAuthorsRequest* request, ::grpc::ServerAsyncResponseWriter< ::proto::GetAuthorsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_UploadReview<WithAsyncMethod_BatchUploadReview<WithAsyncMethod_GetReviewsByAuthor<WithAsyncMethod_GetAuthors<Service > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_UploadReview : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_UploadReview() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::proto::UploadReviewRequest, ::proto::Payload>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::proto::UploadReviewRequest* request, ::proto::Payload* response) { return this->UploadReview(context, request, response); }));}
    void SetMessageAllocatorFor_UploadReview(
        ::grpc::MessageAllocator< ::proto::UploadReviewRequest, ::proto::Payload>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::proto::UploadReviewRequest, ::proto::Payload>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_UploadReview() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadReview(::grpc::ServerContext* /*context*/, const ::proto::UploadReviewRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UploadReview(
      ::grpc::CallbackServerContext* /*context*/, const ::proto::UploadReviewRequest* /*request*/, ::proto::Payload* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_BatchUploadReview : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_BatchUploadReview() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::proto::BatchUploadReviewRequest, ::proto::Payload>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::proto::BatchUploadReviewRequest* request, ::proto::Payload* response) { return this->BatchUploadReview(context, request, response); }));}
    void SetMessageAllocatorFor_BatchUploadReview(
        ::grpc::MessageAllocator< ::proto::BatchUploadReviewRequest, ::proto::Payload>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::proto::BatchUploadReviewRequest, ::proto::Payload>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_BatchUploadReview() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchUploadReview(::grpc::ServerContext* /*context*/, const ::proto::BatchUploadReviewRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BatchUploadReview(
      ::grpc::CallbackServerContext* /*context*/, const ::proto::BatchUploadReviewRequest* /*request*/, ::proto::Payload* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetReviewsByAuthor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetReviewsByAuthor() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::proto::GetReviewsByAuthorRequest, ::proto::GetReviewsByAuthorResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::proto::GetReviewsByAuthorRequest* request, ::proto::GetReviewsByAuthorResponse* response) { return this->GetReviewsByAuthor(context, request, response); }));}
    void SetMessageAllocatorFor_GetReviewsByAuthor(
        ::grpc::MessageAllocator< ::proto::GetReviewsByAuthorRequest, ::proto::GetReviewsByAuthorResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::proto::GetReviewsByAuthorRequest, ::proto::GetReviewsByAuthorResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetReviewsByAuthor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetReviewsByAuthor(::grpc::ServerContext* /*context*/, const ::proto::GetReviewsByAuthorRequest* /*request*/, ::proto::GetReviewsByAuthorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetReviewsByAuthor(
      ::grpc::CallbackServerContext* /*context*/, const ::proto::GetReviewsByAuthorRequest* /*request*/, ::proto::GetReviewsByAuthorResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetAuthors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetAuthors() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::proto::GetAuthorsRequest, ::proto::GetAuthorsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::proto::GetAuthorsRequest* request, ::proto::GetAuthorsResponse* response) { return this->GetAuthors(context, request, response); }));}
    void SetMessageAllocatorFor_GetAuthors(
        ::grpc::MessageAllocator< ::proto::GetAuthorsRequest, ::proto::GetAuthorsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::proto::GetAuthorsRequest, ::proto::GetAuthorsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetAuthors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAuthors(::grpc::ServerContext* /*context*/, const ::proto::GetAuthorsRequest* /*request*/, ::proto::GetAuthorsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetAuthors(
      ::grpc::CallbackServerContext* /*context*/, const ::proto::GetAuthorsRequest* /*request*/, ::proto::GetAuthorsResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_UploadReview<WithCallbackMethod_BatchUploadReview<WithCallbackMethod_GetReviewsByAuthor<WithCallbackMethod_GetAuthors<Service > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_UploadReview : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UploadReview() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_UploadReview() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadReview(::grpc::ServerContext* /*context*/, const ::proto::UploadReviewRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_BatchUploadReview : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_BatchUploadReview() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_BatchUploadReview() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchUploadReview(::grpc::ServerContext* /*context*/, const ::proto::BatchUploadReviewRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetReviewsByAuthor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetReviewsByAuthor() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GetReviewsByAuthor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetReviewsByAuthor(::grpc::ServerContext* /*context*/, const ::proto::GetReviewsByAuthorRequest* /*request*/, ::proto::GetReviewsByAuthorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetAuthors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetAuthors() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetAuthors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAuthors(::grpc::ServerContext* /*context*/, const ::proto::GetAuthorsRequest* /*request*/, ::proto::GetAuthorsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_UploadReview : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UploadReview() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_UploadReview() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadReview(::grpc::ServerContext* /*context*/, const ::proto::UploadReviewRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUploadReview(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_BatchUploadReview : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_BatchUploadReview() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_BatchUploadReview() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchUploadReview(::grpc::ServerContext* /*context*/, const ::proto::BatchUploadReviewRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBatchUploadReview(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetReviewsByAuthor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetReviewsByAuthor() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_GetReviewsByAuthor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetReviewsByAuthor(::grpc::ServerContext* /*context*/, const ::proto::GetReviewsByAuthorRequest* /*request*/, ::proto::GetReviewsByAuthorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetReviewsByAuthor(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetAuthors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetAuthors() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GetAuthors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAuthors(::grpc::ServerContext* /*context*/, const ::proto::GetAuthorsRequest* /*request*/, ::proto::GetAuthorsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAuthors(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_UploadReview : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_UploadReview() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UploadReview(context, request, response); }));
    }
    ~WithRawCallbackMethod_UploadReview() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadReview(::grpc::ServerContext* /*context*/, const ::proto::UploadReviewRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UploadReview(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_BatchUploadReview : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_BatchUploadReview() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->BatchUploadReview(context, request, response); }));
    }
    ~WithRawCallbackMethod_BatchUploadReview() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchUploadReview(::grpc::ServerContext* /*context*/, const ::proto::BatchUploadReviewRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BatchUploadReview(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetReviewsByAuthor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetReviewsByAuthor() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetReviewsByAuthor(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetReviewsByAuthor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetReviewsByAuthor(::grpc::ServerContext* /*context*/, const ::proto::GetReviewsByAuthorRequest* /*request*/, ::proto::GetReviewsByAuthorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetReviewsByAuthor(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetAuthors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetAuthors() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetAuthors(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetAuthors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAuthors(::grpc::ServerContext* /*context*/, const ::proto::GetAuthorsRequest* /*request*/, ::proto::GetAuthorsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetAuthors(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UploadReview : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UploadReview() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::proto::UploadReviewRequest, ::proto::Payload>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::proto::UploadReviewRequest, ::proto::Payload>* streamer) {
                       return this->StreamedUploadReview(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UploadReview() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UploadReview(::grpc::ServerContext* /*context*/, const ::proto::UploadReviewRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUploadReview(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::proto::UploadReviewRequest,::proto::Payload>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_BatchUploadReview : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_BatchUploadReview() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::proto::BatchUploadReviewRequest, ::proto::Payload>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::proto::BatchUploadReviewRequest, ::proto::Payload>* streamer) {
                       return this->StreamedBatchUploadReview(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_BatchUploadReview() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status BatchUploadReview(::grpc::ServerContext* /*context*/, const ::proto::BatchUploadReviewRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBatchUploadReview(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::proto::BatchUploadReviewRequest,::proto::Payload>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetReviewsByAuthor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetReviewsByAuthor() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::proto::GetReviewsByAuthorRequest, ::proto::GetReviewsByAuthorResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::proto::GetReviewsByAuthorRequest, ::proto::GetReviewsByAuthorResponse>* streamer) {
                       return this->StreamedGetReviewsByAuthor(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetReviewsByAuthor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetReviewsByAuthor(::grpc::ServerContext* /*context*/, const ::proto::GetReviewsByAuthorRequest* /*request*/, ::proto::GetReviewsByAuthorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetReviewsByAuthor(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::proto::GetReviewsByAuthorRequest,::proto::GetReviewsByAuthorResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetAuthors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetAuthors() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::proto::GetAuthorsRequest, ::proto::GetAuthorsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::proto::GetAuthorsRequest, ::proto::GetAuthorsResponse>* streamer) {
                       return this->StreamedGetAuthors(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetAuthors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetAuthors(::grpc::ServerContext* /*context*/, const ::proto::GetAuthorsRequest* /*request*/, ::proto::GetAuthorsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetAuthors(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::proto::GetAuthorsRequest,::proto::GetAuthorsResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_UploadReview<WithStreamedUnaryMethod_BatchUploadReview<WithStreamedUnaryMethod_GetReviewsByAuthor<WithStreamedUnaryMethod_GetAuthors<Service > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_UploadReview<WithStreamedUnaryMethod_BatchUploadReview<WithStreamedUnaryMethod_GetReviewsByAuthor<WithStreamedUnaryMethod_GetAuthors<Service > > > > StreamedService;
};

class FilestoreService final {
 public:
  static constexpr char const* service_full_name() {
    return "proto.FilestoreService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status UploadObject(::grpc::ClientContext* context, const ::proto::UploadObjectRequest& request, ::proto::Payload* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>> AsyncUploadObject(::grpc::ClientContext* context, const ::proto::UploadObjectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>>(AsyncUploadObjectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>> PrepareAsyncUploadObject(::grpc::ClientContext* context, const ::proto::UploadObjectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>>(PrepareAsyncUploadObjectRaw(context, request, cq));
    }
    virtual ::grpc::Status DownloadObject(::grpc::ClientContext* context, const ::proto::DownloadObjectRequest& request, ::proto::DownloadObjectResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::DownloadObjectResponse>> AsyncDownloadObject(::grpc::ClientContext* context, const ::proto::DownloadObjectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::DownloadObjectResponse>>(AsyncDownloadObjectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::DownloadObjectResponse>> PrepareAsyncDownloadObject(::grpc::ClientContext* context, const ::proto::DownloadObjectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::DownloadObjectResponse>>(PrepareAsyncDownloadObjectRaw(context, request, cq));
    }
    virtual ::grpc::Status StatObject(::grpc::ClientContext* context, const ::proto::StatObjectRequest& request, ::proto::StatObjectResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::StatObjectResponse>> AsyncStatObject(::grpc::ClientContext* context, const ::proto::StatObjectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::StatObjectResponse>>(AsyncStatObjectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::StatObjectResponse>> PrepareAsyncStatObject(::grpc::ClientContext* context, const ::proto::StatObjectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::StatObjectResponse>>(PrepareAsyncStatObjectRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void UploadObject(::grpc::ClientContext* context, const ::proto::UploadObjectRequest* request, ::proto::Payload* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UploadObject(::grpc::ClientContext* context, const ::proto::UploadObjectRequest* request, ::proto::Payload* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void DownloadObject(::grpc::ClientContext* context, const ::proto::DownloadObjectRequest* request, ::proto::DownloadObjectResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DownloadObject(::grpc::ClientContext* context, const ::proto::DownloadObjectRequest* request, ::proto::DownloadObjectResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void StatObject(::grpc::ClientContext* context, const ::proto::StatObjectRequest* request, ::proto::StatObjectResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StatObject(::grpc::ClientContext* context, const ::proto::StatObjectRequest* request, ::proto::StatObjectResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>* AsyncUploadObjectRaw(::grpc::ClientContext* context, const ::proto::UploadObjectRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>* PrepareAsyncUploadObjectRaw(::grpc::ClientContext* context, const ::proto::UploadObjectRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::DownloadObjectResponse>* AsyncDownloadObjectRaw(::grpc::ClientContext* context, const ::proto::DownloadObjectRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::DownloadObjectResponse>* PrepareAsyncDownloadObjectRaw(::grpc::ClientContext* context, const ::proto::DownloadObjectRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::StatObjectResponse>* AsyncStatObjectRaw(::grpc::ClientContext* context, const ::proto::StatObjectRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::StatObjectResponse>* PrepareAsyncStatObjectRaw(::grpc::ClientContext* context, const ::proto::StatObjectRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status UploadObject(::grpc::ClientContext* context, const ::proto::UploadObjectRequest& request, ::proto::Payload* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>> AsyncUploadObject(::grpc::ClientContext* context, const ::proto::UploadObjectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>>(AsyncUploadObjectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>> PrepareAsyncUploadObject(::grpc::ClientContext* context, const ::proto::UploadObjectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>>(PrepareAsyncUploadObjectRaw(context, request, cq));
    }
    ::grpc::Status DownloadObject(::grpc::ClientContext* context, const ::proto::DownloadObjectRequest& request, ::proto::DownloadObjectResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::DownloadObjectResponse>> AsyncDownloadObject(::grpc::ClientContext* context, const ::proto::DownloadObjectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::DownloadObjectResponse>>(AsyncDownloadObjectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::DownloadObjectResponse>> PrepareAsyncDownloadObject(::grpc::ClientContext* context, const ::proto::DownloadObjectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::DownloadObjectResponse>>(PrepareAsyncDownloadObjectRaw(context, request, cq));
    }
    ::grpc::Status StatObject(::grpc::ClientContext* context, const ::proto::StatObjectRequest& request, ::proto::StatObjectResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::StatObjectResponse>> AsyncStatObject(::grpc::ClientContext* context, const ::proto::StatObjectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::StatObjectResponse>>(AsyncStatObjectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::StatObjectResponse>> PrepareAsyncStatObject(::grpc::ClientContext* context, const ::proto::StatObjectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::StatObjectResponse>>(PrepareAsyncStatObjectRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void UploadObject(::grpc::ClientContext* context, const ::proto::UploadObjectRequest* request, ::proto::Payload* response, std::function<void(::grpc::Status)>) override;
      void UploadObject(::grpc::ClientContext* context, const ::proto::UploadObjectRequest* request, ::proto::Payload* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DownloadObject(::grpc::ClientContext* context, const ::proto::DownloadObjectRequest* request, ::proto::DownloadObjectResponse* response, std::function<void(::grpc::Status)>) override;
      void DownloadObject(::grpc::ClientContext* context, const ::proto::DownloadObjectRequest* request, ::proto::DownloadObjectResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void StatObject(::grpc::ClientContext* context, const ::proto::StatObjectRequest* request, ::proto::StatObjectResponse* response, std::function<void(::grpc::Status)>) override;
      void StatObject(::grpc::ClientContext* context, const ::proto::StatObjectRequest* request, ::proto::StatObjectResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::proto::Payload>* AsyncUploadObjectRaw(::grpc::ClientContext* context, const ::proto::UploadObjectRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::Payload>* PrepareAsyncUploadObjectRaw(::grpc::ClientContext* context, const ::proto::UploadObjectRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::DownloadObjectResponse>* AsyncDownloadObjectRaw(::grpc::ClientContext* context, const ::proto::DownloadObjectRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::DownloadObjectResponse>* PrepareAsyncDownloadObjectRaw(::grpc::ClientContext* context, const ::proto::DownloadObjectRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::StatObjectResponse>* AsyncStatObjectRaw(::grpc::ClientContext* context, const ::proto::StatObjectRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::StatObjectResponse>* PrepareAsyncStatObjectRaw(::grpc::ClientContext* context, const ::proto::StatObjectRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_UploadObject_;
    const ::grpc::internal::RpcMethod rpcmethod_DownloadObject_;
    const ::grpc::internal::RpcMethod rpcmethod_StatObject_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status UploadObject(::grpc::ServerContext* context, const ::proto::UploadObjectRequest* request, ::proto::Payload* response);
    virtual ::grpc::Status DownloadObject(::grpc::ServerContext* context, const ::proto::DownloadObjectRequest* request, ::proto::DownloadObjectResponse* response);
    virtual ::grpc::Status StatObject(::grpc::ServerContext* context, const ::proto::StatObjectRequest* request, ::proto::StatObjectResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_UploadObject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UploadObject() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_UploadObject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadObject(::grpc::ServerContext* /*context*/, const ::proto::UploadObjectRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUploadObject(::grpc::ServerContext* context, ::proto::UploadObjectRequest* request, ::grpc::ServerAsyncResponseWriter< ::proto::Payload>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DownloadObject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DownloadObject() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_DownloadObject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadObject(::grpc::ServerContext* /*context*/, const ::proto::DownloadObjectRequest* /*request*/, ::proto::DownloadObjectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDownloadObject(::grpc::ServerContext* context, ::proto::DownloadObjectRequest* request, ::grpc::ServerAsyncResponseWriter< ::proto::DownloadObjectResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StatObject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StatObject() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_StatObject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StatObject(::grpc::ServerContext* /*context*/, const ::proto::StatObjectRequest* /*request*/, ::proto::StatObjectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStatObject(::grpc::ServerContext* context, ::proto::StatObjectRequest* request, ::grpc::ServerAsyncResponseWriter< ::proto::StatObjectResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_UploadObject<WithAsyncMethod_DownloadObject<WithAsyncMethod_StatObject<Service > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_UploadObject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_UploadObject() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::proto::UploadObjectRequest, ::proto::Payload>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::proto::UploadObjectRequest* request, ::proto::Payload* response) { return this->UploadObject(context, request, response); }));}
    void SetMessageAllocatorFor_UploadObject(
        ::grpc::MessageAllocator< ::proto::UploadObjectRequest, ::proto::Payload>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::proto::UploadObjectRequest, ::proto::Payload>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_UploadObject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadObject(::grpc::ServerContext* /*context*/, const ::proto::UploadObjectRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UploadObject(
      ::grpc::CallbackServerContext* /*context*/, const ::proto::UploadObjectRequest* /*request*/, ::proto::Payload* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DownloadObject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DownloadObject() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::proto::DownloadObjectRequest, ::proto::DownloadObjectResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::proto::DownloadObjectRequest* request, ::proto::DownloadObjectResponse* response) { return this->DownloadObject(context, request, response); }));}
    void SetMessageAllocatorFor_DownloadObject(
        ::grpc::MessageAllocator< ::proto::DownloadObjectRequest, ::proto::DownloadObjectResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::proto::DownloadObjectRequest, ::proto::DownloadObjectResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DownloadObject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadObject(::grpc::ServerContext* /*context*/, const ::proto::DownloadObjectRequest* /*request*/, ::proto::DownloadObjectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DownloadObject(
      ::grpc::CallbackServerContext* /*context*/, const ::proto::DownloadObjectRequest* /*request*/, ::proto::DownloadObjectResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StatObject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StatObject() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::proto::StatObjectRequest, ::proto::StatObjectResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::proto::StatObjectRequest* request, ::proto::StatObjectResponse* response) { return this->StatObject(context, request, response); }));}
    void SetMessageAllocatorFor_StatObject(
        ::grpc::MessageAllocator< ::proto::StatObjectRequest, ::proto::StatObjectResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::proto::StatObjectRequest, ::proto::StatObjectResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_StatObject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StatObject(::grpc::ServerContext* /*context*/, const ::proto::StatObjectRequest* /*request*/, ::proto::StatObjectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StatObject(
      ::grpc::CallbackServerContext* /*context*/, const ::proto::StatObjectRequest* /*request*/, ::proto::StatObjectResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_UploadObject<WithCallbackMethod_DownloadObject<WithCallbackMethod_StatObject<Service > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_UploadObject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UploadObject() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_UploadObject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadObject(::grpc::ServerContext* /*context*/, const ::proto::UploadObjectRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DownloadObject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DownloadObject() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_DownloadObject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadObject(::grpc::ServerContext* /*context*/, const ::proto::DownloadObjectRequest* /*request*/, ::proto::DownloadObjectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StatObject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StatObject() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_StatObject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StatObject(::grpc::ServerContext* /*context*/, const ::proto::StatObjectRequest* /*request*/, ::proto::StatObjectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_UploadObject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UploadObject() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_UploadObject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadObject(::grpc::ServerContext* /*context*/, const ::proto::UploadObjectRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUploadObject(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DownloadObject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DownloadObject() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_DownloadObject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadObject(::grpc::ServerContext* /*context*/, const ::proto::DownloadObjectRequest* /*request*/, ::proto::DownloadObjectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDownloadObject(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StatObject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StatObject() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_StatObject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StatObject(::grpc::ServerContext* /*context*/, const ::proto::StatObjectRequest* /*request*/, ::proto::StatObjectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStatObject(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_UploadObject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_UploadObject() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UploadObject(context, request, response); }));
    }
    ~WithRawCallbackMethod_UploadObject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadObject(::grpc::ServerContext* /*context*/, const ::proto::UploadObjectRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UploadObject(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DownloadObject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DownloadObject() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DownloadObject(context, request, response); }));
    }
    ~WithRawCallbackMethod_DownloadObject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadObject(::grpc::ServerContext* /*context*/, const ::proto::DownloadObjectRequest* /*request*/, ::proto::DownloadObjectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DownloadObject(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StatObject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StatObject() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->StatObject(context, request, response); }));
    }
    ~WithRawCallbackMethod_StatObject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StatObject(::grpc::ServerContext* /*context*/, const ::proto::StatObjectRequest* /*request*/, ::proto::StatObjectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StatObject(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UploadObject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UploadObject() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::proto::UploadObjectRequest, ::proto::Payload>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::proto::UploadObjectRequest, ::proto::Payload>* streamer) {
                       return this->StreamedUploadObject(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UploadObject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UploadObject(::grpc::ServerContext* /*context*/, const ::proto::UploadObjectRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUploadObject(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::proto::UploadObjectRequest,::proto::Payload>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DownloadObject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DownloadObject() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::proto::DownloadObjectRequest, ::proto::DownloadObjectResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::proto::DownloadObjectRequest, ::proto::DownloadObjectResponse>* streamer) {
                       return this->StreamedDownloadObject(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DownloadObject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DownloadObject(::grpc::ServerContext* /*context*/, const ::proto::DownloadObjectRequest* /*request*/, ::proto::DownloadObjectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDownloadObject(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::proto::DownloadObjectRequest,::proto::DownloadObjectResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StatObject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StatObject() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::proto::StatObjectRequest, ::proto::StatObjectResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::proto::StatObjectRequest, ::proto::StatObjectResponse>* streamer) {
                       return this->StreamedStatObject(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_StatObject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StatObject(::grpc::ServerContext* /*context*/, const ::proto::StatObjectRequest* /*request*/, ::proto::StatObjectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStatObject(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::proto::StatObjectRequest,::proto::StatObjectResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_UploadObject<WithStreamedUnaryMethod_DownloadObject<WithStreamedUnaryMethod_StatObject<Service > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_UploadObject<WithStreamedUnaryMethod_DownloadObject<WithStreamedUnaryMethod_StatObject<Service > > > StreamedService;
};

class DatastoreAdminService final {
 public:
  static constexpr char const* service_full_name() {
    return "proto.DatastoreAdminService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status ManageResource(::grpc::ClientContext* context, const ::proto::ManageResourceRequest& request, ::proto::Payload* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>> AsyncManageResource(::grpc::ClientContext* context, const ::proto::ManageResourceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>>(AsyncManageResourceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>> PrepareAsyncManageResource(::grpc::ClientContext* context, const ::proto::ManageResourceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>>(PrepareAsyncManageResourceRaw(context, request, cq));
    }
    virtual ::grpc::Status CheckHealth(::grpc::ClientContext* context, const ::proto::HealthCheckRequest& request, ::proto::Payload* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>> AsyncCheckHealth(::grpc::ClientContext* context, const ::proto::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>>(AsyncCheckHealthRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>> PrepareAsyncCheckHealth(::grpc::ClientContext* context, const ::proto::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>>(PrepareAsyncCheckHealthRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void ManageResource(::grpc::ClientContext* context, const ::proto::ManageResourceRequest* request, ::proto::Payload* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ManageResource(::grpc::ClientContext* context, const ::proto::ManageResourceRequest* request, ::proto::Payload* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void CheckHealth(::grpc::ClientContext* context, const ::proto::HealthCheckRequest* request, ::proto::Payload* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CheckHealth(::grpc::ClientContext* context, const ::proto::HealthCheckRequest* request, ::proto::Payload* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>* AsyncManageResourceRaw(::grpc::ClientContext* context, const ::proto::ManageResourceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>* PrepareAsyncManageResourceRaw(::grpc::ClientContext* context, const ::proto::ManageResourceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>* AsyncCheckHealthRaw(::grpc::ClientContext* context, const ::proto::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>* PrepareAsyncCheckHealthRaw(::grpc::ClientContext* context, const ::proto::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status ManageResource(::grpc::ClientContext* context, const ::proto::ManageResourceRequest& request, ::proto::Payload* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>> AsyncManageResource(::grpc::ClientContext* context, const ::proto::ManageResourceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>>(AsyncManageResourceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>> PrepareAsyncManageResource(::grpc::ClientContext* context, const ::proto::ManageResourceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>>(PrepareAsyncManageResourceRaw(context, request, cq));
    }
    ::grpc::Status CheckHealth(::grpc::ClientContext* context, const ::proto::HealthCheckRequest& request, ::proto::Payload* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>> AsyncCheckHealth(::grpc::ClientContext* context, const ::proto::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>>(AsyncCheckHealthRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>> PrepareAsyncCheckHealth(::grpc::ClientContext* context, const ::proto::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>>(PrepareAsyncCheckHealthRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void ManageResource(::grpc::ClientContext* context, const ::proto::ManageResourceRequest* request, ::proto::Payload* response, std::function<void(::grpc::Status)>) override;
      void ManageResource(::grpc::ClientContext* context, const ::proto::ManageResourceRequest* request, ::proto::Payload* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CheckHealth(::grpc::ClientContext* context, const ::proto::HealthCheckRequest* request, ::proto::Payload* response, std::function<void(::grpc::Status)>) override;
      void CheckHealth(::grpc::ClientContext* context, const ::proto::HealthCheckRequest* request, ::proto::Payload* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::proto::Payload>* AsyncManageResourceRaw(::grpc::ClientContext* context, const ::proto::ManageResourceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::Payload>* PrepareAsyncManageResourceRaw(::grpc::ClientContext* context, const ::proto::ManageResourceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::Payload>* AsyncCheckHealthRaw(::grpc::ClientContext* context, const ::proto::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::Payload>* PrepareAsyncCheckHealthRaw(::grpc::ClientContext* context, const ::proto::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_ManageResource_;
    const ::grpc::internal::RpcMethod rpcmethod_CheckHealth_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status ManageResource(::grpc::ServerContext* context, const ::proto::ManageResourceRequest* request, ::proto::Payload* response);
    virtual ::grpc::Status CheckHealth(::grpc::ServerContext* context, const ::proto::HealthCheckRequest* request, ::proto::Payload* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_ManageResource : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ManageResource() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_ManageResource() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ManageResource(::grpc::ServerContext* /*context*/, const ::proto::ManageResourceRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestManageResource(::grpc::ServerContext* context, ::proto::ManageResourceRequest* request, ::grpc::ServerAsyncResponseWriter< ::proto::Payload>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CheckHealth : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CheckHealth() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_CheckHealth() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckHealth(::grpc::ServerContext* /*context*/, const ::proto::HealthCheckRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheckHealth(::grpc::ServerContext* context, ::proto::HealthCheckRequest* request, ::grpc::ServerAsyncResponseWriter< ::proto::Payload>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_ManageResource<WithAsyncMethod_CheckHealth<Service > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_ManageResource : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ManageResource() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::proto::ManageResourceRequest, ::proto::Payload>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::proto::ManageResourceRequest* request, ::proto::Payload* response) { return this->ManageResource(context, request, response); }));}
    void SetMessageAllocatorFor_ManageResource(
        ::grpc::MessageAllocator< ::proto::ManageResourceRequest, ::proto::Payload>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::proto::ManageResourceRequest, ::proto::Payload>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ManageResource() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ManageResource(::grpc::ServerContext* /*context*/, const ::proto::ManageResourceRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ManageResource(
      ::grpc::CallbackServerContext* /*context*/, const ::proto::ManageResourceRequest* /*request*/, ::proto::Payload* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CheckHealth : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CheckHealth() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::proto::HealthCheckRequest, ::proto::Payload>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::proto::HealthCheckRequest* request, ::proto::Payload* response) { return this->CheckHealth(context, request, response); }));}
    void SetMessageAllocatorFor_CheckHealth(
        ::grpc::MessageAllocator< ::proto::HealthCheckRequest, ::proto::Payload>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::proto::HealthCheckRequest, ::proto::Payload>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CheckHealth() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckHealth(::grpc::ServerContext* /*context*/, const ::proto::HealthCheckRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CheckHealth(
      ::grpc::CallbackServerContext* /*context*/, const ::proto::HealthCheckRequest* /*request*/, ::proto::Payload* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_ManageResource<WithCallbackMethod_CheckHealth<Service > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_ManageResource : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ManageResource() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_ManageResource() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ManageResource(::grpc::ServerContext* /*context*/, const ::proto::ManageResourceRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CheckHealth : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CheckHealth() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_CheckHealth() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckHealth(::grpc::ServerContext* /*context*/, const ::proto::HealthCheckRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_ManageResource : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ManageResource() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_ManageResource() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ManageResource(::grpc::ServerContext* /*context*/, const ::proto::ManageResourceRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestManageResource(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CheckHealth : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CheckHealth() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_CheckHealth() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckHealth(::grpc::ServerContext* /*context*/, const ::proto::HealthCheckRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheckHealth(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ManageResource : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ManageResource() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ManageResource(context, request, response); }));
    }
    ~WithRawCallbackMethod_ManageResource() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ManageResource(::grpc::ServerContext* /*context*/, const ::proto::ManageResourceRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ManageResource(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CheckHealth : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CheckHealth() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CheckHealth(context, request, response); }));
    }
    ~WithRawCallbackMethod_CheckHealth() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckHealth(::grpc::ServerContext* /*context*/, const ::proto::HealthCheckRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CheckHealth(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ManageResource : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ManageResource() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::proto::ManageResourceRequest, ::proto::Payload>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::proto::ManageResourceRequest, ::proto::Payload>* streamer) {
                       return this->StreamedManageResource(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ManageResource() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ManageResource(::grpc::ServerContext* /*context*/, const ::proto::ManageResourceRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedManageResource(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::proto::ManageResourceRequest,::proto::Payload>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CheckHealth : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CheckHealth() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::proto::HealthCheckRequest, ::proto::Payload>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::proto::HealthCheckRequest, ::proto::Payload>* streamer) {
                       return this->StreamedCheckHealth(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CheckHealth() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CheckHealth(::grpc::ServerContext* /*context*/, const ::proto::HealthCheckRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCheckHealth(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::proto::HealthCheckRequest,::proto::Payload>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_ManageResource<WithStreamedUnaryMethod_CheckHealth<Service > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_ManageResource<WithStreamedUnaryMethod_CheckHealth<Service > > StreamedService;
};

class IngestionService final {
 public:
  static constexpr char const* service_full_name() {
    return "proto.IngestionService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status IngestReview(::grpc::ClientContext* context, const ::proto::IngestReviewRequest& request, ::proto::Payload* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>> AsyncIngestReview(::grpc::ClientContext* context, const ::proto::IngestReviewRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>>(AsyncIngestReviewRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>> PrepareAsyncIngestReview(::grpc::ClientContext* context, const ::proto::IngestReviewRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>>(PrepareAsyncIngestReviewRaw(context, request, cq));
    }
    virtual ::grpc::Status IngestBatch(::grpc::ClientContext* context, const ::proto::IngestBatchRequest& request, ::proto::Payload* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>> AsyncIngestBatch(::grpc::ClientContext* context, const ::proto::IngestBatchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>>(AsyncIngestBatchRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>> PrepareAsyncIngestBatch(::grpc::ClientContext* context, const ::proto::IngestBatchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>>(PrepareAsyncIngestBatchRaw(context, request, cq));
    }
    virtual ::grpc::Status CheckHealth(::grpc::ClientContext* context, const ::proto::HealthCheckRequest& request, ::proto::Payload* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>> AsyncCheckHealth(::grpc::ClientContext* context, const ::proto::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>>(AsyncCheckHealthRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>> PrepareAsyncCheckHealth(::grpc::ClientContext* context, const ::proto::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>>(PrepareAsyncCheckHealthRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void IngestReview(::grpc::ClientContext* context, const ::proto::IngestReviewRequest* request, ::proto::Payload* response, std::function<void(::grpc::Status)>) = 0;
      virtual void IngestReview(::grpc::ClientContext* context, const ::proto::IngestReviewRequest* request, ::proto::Payload* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void IngestBatch(::grpc::ClientContext* context, const ::proto::IngestBatchRequest* request, ::proto::Payload* response, std::function<void(::grpc::Status)>) = 0;
      virtual void IngestBatch(::grpc::ClientContext* context, const ::proto::IngestBatchRequest* request, ::proto::Payload* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void CheckHealth(::grpc::ClientContext* context, const ::proto::HealthCheckRequest* request, ::proto::Payload* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CheckHealth(::grpc::ClientContext* context, const ::proto::HealthCheckRequest* request, ::proto::Payload* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>* AsyncIngestReviewRaw(::grpc::ClientContext* context, const ::proto::IngestReviewRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>* PrepareAsyncIngestReviewRaw(::grpc::ClientContext* context, const ::proto::IngestReviewRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>* AsyncIngestBatchRaw(::grpc::ClientContext* context, const ::proto::IngestBatchRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>* PrepareAsyncIngestBatchRaw(::grpc::ClientContext* context, const ::proto::IngestBatchRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>* AsyncCheckHealthRaw(::grpc::ClientContext* context, const ::proto::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>* PrepareAsyncCheckHealthRaw(::grpc::ClientContext* context, const ::proto::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status IngestReview(::grpc::ClientContext* context, const ::proto::IngestReviewRequest& request, ::proto::Payload* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>> AsyncIngestReview(::grpc::ClientContext* context, const ::proto::IngestReviewRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>>(AsyncIngestReviewRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>> PrepareAsyncIngestReview(::grpc::ClientContext* context, const ::proto::IngestReviewRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>>(PrepareAsyncIngestReviewRaw(context, request, cq));
    }
    ::grpc::Status IngestBatch(::grpc::ClientContext* context, const ::proto::IngestBatchRequest& request, ::proto::Payload* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>> AsyncIngestBatch(::grpc::ClientContext* context, const ::proto::IngestBatchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>>(AsyncIngestBatchRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>> PrepareAsyncIngestBatch(::grpc::ClientContext* context, const ::proto::IngestBatchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>>(PrepareAsyncIngestBatchRaw(context, request, cq));
    }
    ::grpc::Status CheckHealth(::grpc::ClientContext* context, const ::proto::HealthCheckRequest& request, ::proto::Payload* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>> AsyncCheckHealth(::grpc::ClientContext* context, const ::proto::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>>(AsyncCheckHealthRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>> PrepareAsyncCheckHealth(::grpc::ClientContext* context, const ::proto::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>>(PrepareAsyncCheckHealthRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void IngestReview(::grpc::ClientContext* context, const ::proto::IngestReviewRequest* request, ::proto::Payload* response, std::function<void(::grpc::Status)>) override;
      void IngestReview(::grpc::ClientContext* context, const ::proto::IngestReviewRequest* request, ::proto::Payload* response, ::grpc::ClientUnaryReactor* reactor) override;
      void IngestBatch(::grpc::ClientContext* context, const ::proto::IngestBatchRequest* request, ::proto::Payload* response, std::function<void(::grpc::Status)>) override;
      void IngestBatch(::grpc::ClientContext* context, const ::proto::IngestBatchRequest* request, ::proto::Payload* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CheckHealth(::grpc::ClientContext* context, const ::proto::HealthCheckRequest* request, ::proto::Payload* response, std::function<void(::grpc::Status)>) override;
      void CheckHealth(::grpc::ClientContext* context, const ::proto::HealthCheckRequest* request, ::proto::Payload* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::proto::Payload>* AsyncIngestReviewRaw(::grpc::ClientContext* context, const ::proto::IngestReviewRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::Payload>* PrepareAsyncIngestReviewRaw(::grpc::ClientContext* context, const ::proto::IngestReviewRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::Payload>* AsyncIngestBatchRaw(::grpc::ClientContext* context, const ::proto::IngestBatchRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::Payload>* PrepareAsyncIngestBatchRaw(::grpc::ClientContext* context, const ::proto::IngestBatchRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::Payload>* AsyncCheckHealthRaw(::grpc::ClientContext* context, const ::proto::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::Payload>* PrepareAsyncCheckHealthRaw(::grpc::ClientContext* context, const ::proto::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_IngestReview_;
    const ::grpc::internal::RpcMethod rpcmethod_IngestBatch_;
    const ::grpc::internal::RpcMethod rpcmethod_CheckHealth_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status IngestReview(::grpc::ServerContext* context, const ::proto::IngestReviewRequest* request, ::proto::Payload* response);
    virtual ::grpc::Status IngestBatch(::grpc::ServerContext* context, const ::proto::IngestBatchRequest* request, ::proto::Payload* response);
    virtual ::grpc::Status CheckHealth(::grpc::ServerContext* context, const ::proto::HealthCheckRequest* request, ::proto::Payload* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_IngestReview : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_IngestReview() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_IngestReview() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IngestReview(::grpc::ServerContext* /*context*/, const ::proto::IngestReviewRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestIngestReview(::grpc::ServerContext* context, ::proto::IngestReviewRequest* request, ::grpc::ServerAsyncResponseWriter< ::proto::Payload>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_IngestBatch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_IngestBatch() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_IngestBatch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IngestBatch(::grpc::ServerContext* /*context*/, const ::proto::IngestBatchRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestIngestBatch(::grpc::ServerContext* context, ::proto::IngestBatchRequest* request, ::grpc::ServerAsyncResponseWriter< ::proto::Payload>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CheckHealth : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CheckHealth() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_CheckHealth() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckHealth(::grpc::ServerContext* /*context*/, const ::proto::HealthCheckRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheckHealth(::grpc::ServerContext* context, ::proto::HealthCheckRequest* request, ::grpc::ServerAsyncResponseWriter< ::proto::Payload>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_IngestReview<WithAsyncMethod_IngestBatch<WithAsyncMethod_CheckHealth<Service > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_IngestReview : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_IngestReview() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::proto::IngestReviewRequest, ::proto::Payload>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::proto::IngestReviewRequest* request, ::proto::Payload* response) { return this->IngestReview(context, request, response); }));}
    void SetMessageAllocatorFor_IngestReview(
        ::grpc::MessageAllocator< ::proto::IngestReviewRequest, ::proto::Payload>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::proto::IngestReviewRequest, ::proto::Payload>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_IngestReview() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IngestReview(::grpc::ServerContext* /*context*/, const ::proto::IngestReviewRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* IngestReview(
      ::grpc::CallbackServerContext* /*context*/, const ::proto::IngestReviewRequest* /*request*/, ::proto::Payload* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_IngestBatch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_IngestBatch() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::proto::IngestBatchRequest, ::proto::Payload>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::proto::IngestBatchRequest* request, ::proto::Payload* response) { return this->IngestBatch(context, request, response); }));}
    void SetMessageAllocatorFor_IngestBatch(
        ::grpc::MessageAllocator< ::proto::IngestBatchRequest, ::proto::Payload>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::proto::IngestBatchRequest, ::proto::Payload>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_IngestBatch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IngestBatch(::grpc::ServerContext* /*context*/, const ::proto::IngestBatchRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* IngestBatch(
      ::grpc::CallbackServerContext* /*context*/, const ::proto::IngestBatchRequest* /*request*/, ::proto::Payload* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CheckHealth : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CheckHealth() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::proto::HealthCheckRequest, ::proto::Payload>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::proto::HealthCheckRequest* request, ::proto::Payload* response) { return this->CheckHealth(context, request, response); }));}
    void SetMessageAllocatorFor_CheckHealth(
        ::grpc::MessageAllocator< ::proto::HealthCheckRequest, ::proto::Payload>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::proto::HealthCheckRequest, ::proto::Payload>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CheckHealth() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckHealth(::grpc::ServerContext* /*context*/, const ::proto::HealthCheckRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CheckHealth(
      ::grpc::CallbackServerContext* /*context*/, const ::proto::HealthCheckRequest* /*request*/, ::proto::Payload* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_IngestReview<WithCallbackMethod_IngestBatch<WithCallbackMethod_CheckHealth<Service > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_IngestReview : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_IngestReview() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_IngestReview() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IngestReview(::grpc::ServerContext* /*context*/, const ::proto::IngestReviewRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_IngestBatch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_IngestBatch() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_IngestBatch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IngestBatch(::grpc::ServerContext* /*context*/, const ::proto::IngestBatchRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CheckHealth : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CheckHealth() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_CheckHealth() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckHealth(::grpc::ServerContext* /*context*/, const ::proto::HealthCheckRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_IngestReview : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_IngestReview() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_IngestReview() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IngestReview(::grpc::ServerContext* /*context*/, const ::proto::IngestReviewRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestIngestReview(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_IngestBatch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_IngestBatch() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_IngestBatch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IngestBatch(::grpc::ServerContext* /*context*/, const ::proto::IngestBatchRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestIngestBatch(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CheckHealth : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CheckHealth() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_CheckHealth() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckHealth(::grpc::ServerContext* /*context*/, const ::proto::HealthCheckRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheckHealth(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_IngestReview : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_IngestReview() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->IngestReview(context, request, response); }));
    }
    ~WithRawCallbackMethod_IngestReview() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IngestReview(::grpc::ServerContext* /*context*/, const ::proto::IngestReviewRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* IngestReview(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_IngestBatch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_IngestBatch() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->IngestBatch(context, request, response); }));
    }
    ~WithRawCallbackMethod_IngestBatch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IngestBatch(::grpc::ServerContext* /*context*/, const ::proto::IngestBatchRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* IngestBatch(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CheckHealth : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CheckHealth() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CheckHealth(context, request, response); }));
    }
    ~WithRawCallbackMethod_CheckHealth() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckHealth(::grpc::ServerContext* /*context*/, const ::proto::HealthCheckRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CheckHealth(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_IngestReview : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_IngestReview() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::proto::IngestReviewRequest, ::proto::Payload>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::proto::IngestReviewRequest, ::proto::Payload>* streamer) {
                       return this->StreamedIngestReview(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_IngestReview() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status IngestReview(::grpc::ServerContext* /*context*/, const ::proto::IngestReviewRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedIngestReview(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::proto::IngestReviewRequest,::proto::Payload>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_IngestBatch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_IngestBatch() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::proto::IngestBatchRequest, ::proto::Payload>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::proto::IngestBatchRequest, ::proto::Payload>* streamer) {
                       return this->StreamedIngestBatch(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_IngestBatch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status IngestBatch(::grpc::ServerContext* /*context*/, const ::proto::IngestBatchRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedIngestBatch(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::proto::IngestBatchRequest,::proto::Payload>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CheckHealth : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CheckHealth() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::proto::HealthCheckRequest, ::proto::Payload>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::proto::HealthCheckRequest, ::proto::Payload>* streamer) {
                       return this->StreamedCheckHealth(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CheckHealth() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CheckHealth(::grpc::ServerContext* /*context*/, const ::proto::HealthCheckRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCheckHealth(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::proto::HealthCheckRequest,::proto::Payload>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_IngestReview<WithStreamedUnaryMethod_IngestBatch<WithStreamedUnaryMethod_CheckHealth<Service > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_IngestReview<WithStreamedUnaryMethod_IngestBatch<WithStreamedUnaryMethod_CheckHealth<Service > > > StreamedService;
};

class UploadService final {
 public:
  static constexpr char const* service_full_name() {
    return "proto.UploadService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status UploadFile(::grpc::ClientContext* context, const ::proto::UploadFileRequest& request, ::proto::Payload* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>> AsyncUploadFile(::grpc::ClientContext* context, const ::proto::UploadFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>>(AsyncUploadFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>> PrepareAsyncUploadFile(::grpc::ClientContext* context, const ::proto::UploadFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>>(PrepareAsyncUploadFileRaw(context, request, cq));
    }
    virtual ::grpc::Status CheckHealth(::grpc::ClientContext* context, const ::proto::HealthCheckRequest& request, ::proto::Payload* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>> AsyncCheckHealth(::grpc::ClientContext* context, const ::proto::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>>(AsyncCheckHealthRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>> PrepareAsyncCheckHealth(::grpc::ClientContext* context, const ::proto::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>>(PrepareAsyncCheckHealthRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void UploadFile(::grpc::ClientContext* context, const ::proto::UploadFileRequest* request, ::proto::Payload* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UploadFile(::grpc::ClientContext* context, const ::proto::UploadFileRequest* request, ::proto::Payload* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void CheckHealth(::grpc::ClientContext* context, const ::proto::HealthCheckRequest* request, ::proto::Payload* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CheckHealth(::grpc::ClientContext* context, const ::proto::HealthCheckRequest* request, ::proto::Payload* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>* AsyncUploadFileRaw(::grpc::ClientContext* context, const ::proto::UploadFileRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>* PrepareAsyncUploadFileRaw(::grpc::ClientContext* context, const ::proto::UploadFileRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>* AsyncCheckHealthRaw(::grpc::ClientContext* context, const ::proto::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>* PrepareAsyncCheckHealthRaw(::grpc::ClientContext* context, const ::proto::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status UploadFile(::grpc::ClientContext* context, const ::proto::UploadFileRequest& request, ::proto::Payload* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>> AsyncUploadFile(::grpc::ClientContext* context, const ::proto::UploadFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>>(AsyncUploadFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>> PrepareAsyncUploadFile(::grpc::ClientContext* context, const ::proto::UploadFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>>(PrepareAsyncUploadFileRaw(context, request, cq));
    }
    ::grpc::Status CheckHealth(::grpc::ClientContext* context, const ::proto::HealthCheckRequest& request, ::proto::Payload* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>> AsyncCheckHealth(::grpc::ClientContext* context, const ::proto::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>>(AsyncCheckHealthRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>> PrepareAsyncCheckHealth(::grpc::ClientContext* context, const ::proto::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>>(PrepareAsyncCheckHealthRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void UploadFile(::grpc::ClientContext* context, const ::proto::UploadFileRequest* request, ::proto::Payload* response, std::function<void(::grpc::Status)>) override;
      void UploadFile(::grpc::ClientContext* context, const ::proto::UploadFileRequest* request, ::proto::Payload* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CheckHealth(::grpc::ClientContext* context, const ::proto::HealthCheckRequest* request, ::proto::Payload* response, std::function<void(::grpc::Status)>) override;
      void CheckHealth(::grpc::ClientContext* context, const ::proto::HealthCheckRequest* request, ::proto::Payload* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::proto::Payload>* AsyncUploadFileRaw(::grpc::ClientContext* context, const ::proto::UploadFileRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::Payload>* PrepareAsyncUploadFileRaw(::grpc::ClientContext* context, const ::proto::UploadFileRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::Payload>* AsyncCheckHealthRaw(::grpc::ClientContext* context, const ::proto::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::Payload>* PrepareAsyncCheckHealthRaw(::grpc::ClientContext* context, const ::proto::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_UploadFile_;
    const ::grpc::internal::RpcMethod rpcmethod_CheckHealth_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status UploadFile(::grpc::ServerContext* context, const ::proto::UploadFileRequest* request, ::proto::Payload* response);
    virtual ::grpc::Status CheckHealth(::grpc::ServerContext* context, const ::proto::HealthCheckRequest* request, ::proto::Payload* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_UploadFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UploadFile() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_UploadFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadFile(::grpc::ServerContext* /*context*/, const ::proto::UploadFileRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUploadFile(::grpc::ServerContext* context, ::proto::UploadFileRequest* request, ::grpc::ServerAsyncResponseWriter< ::proto::Payload>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CheckHealth : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CheckHealth() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_CheckHealth() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckHealth(::grpc::ServerContext* /*context*/, const ::proto::HealthCheckRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheckHealth(::grpc::ServerContext* context, ::proto::HealthCheckRequest* request, ::grpc::ServerAsyncResponseWriter< ::proto::Payload>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_UploadFile<WithAsyncMethod_CheckHealth<Service > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_UploadFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_UploadFile() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::proto::UploadFileRequest, ::proto::Payload>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::proto::UploadFileRequest* request, ::proto::Payload* response) { return this->UploadFile(context, request, response); }));}
    void SetMessageAllocatorFor_UploadFile(
        ::grpc::MessageAllocator< ::proto::UploadFileRequest, ::proto::Payload>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::proto::UploadFileRequest, ::proto::Payload>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_UploadFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadFile(::grpc::ServerContext* /*context*/, const ::proto::UploadFileRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UploadFile(
      ::grpc::CallbackServerContext* /*context*/, const ::proto::UploadFileRequest* /*request*/, ::proto::Payload* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CheckHealth : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CheckHealth() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::proto::HealthCheckRequest, ::proto::Payload>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::proto::HealthCheckRequest* request, ::proto::Payload* response) { return this->CheckHealth(context, request, response); }));}
    void SetMessageAllocatorFor_CheckHealth(
        ::grpc::MessageAllocator< ::proto::HealthCheckRequest, ::proto::Payload>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::proto::HealthCheckRequest, ::proto::Payload>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CheckHealth() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckHealth(::grpc::ServerContext* /*context*/, const ::proto::HealthCheckRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CheckHealth(
      ::grpc::CallbackServerContext* /*context*/, const ::proto::HealthCheckRequest* /*request*/, ::proto::Payload* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_UploadFile<WithCallbackMethod_CheckHealth<Service > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_UploadFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UploadFile() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_UploadFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadFile(::grpc::ServerContext* /*context*/, const ::proto::UploadFileRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CheckHealth : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CheckHealth() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_CheckHealth() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckHealth(::grpc::ServerContext* /*context*/, const ::proto::HealthCheckRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_UploadFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UploadFile() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_UploadFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadFile(::grpc::ServerContext* /*context*/, const ::proto::UploadFileRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUploadFile(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CheckHealth : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CheckHealth() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_CheckHealth() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckHealth(::grpc::ServerContext* /*context*/, const ::proto::HealthCheckRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheckHealth(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_UploadFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_UploadFile() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UploadFile(context, request, response); }));
    }
    ~WithRawCallbackMethod_UploadFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadFile(::grpc::ServerContext* /*context*/, const ::proto::UploadFileRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UploadFile(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CheckHealth : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CheckHealth() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CheckHealth(context, request, response); }));
    }
    ~WithRawCallbackMethod_CheckHealth() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckHealth(::grpc::ServerContext* /*context*/, const ::proto::HealthCheckRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CheckHealth(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UploadFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UploadFile() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::proto::UploadFileRequest, ::proto::Payload>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::proto::UploadFileRequest, ::proto::Payload>* streamer) {
                       return this->StreamedUploadFile(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UploadFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UploadFile(::grpc::ServerContext* /*context*/, const ::proto::UploadFileRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUploadFile(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::proto::UploadFileRequest,::proto::Payload>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CheckHealth : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CheckHealth() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::proto::HealthCheckRequest, ::proto::Payload>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::proto::HealthCheckRequest, ::proto::Payload>* streamer) {
                       return this->StreamedCheckHealth(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CheckHealth() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CheckHealth(::grpc::ServerContext* /*context*/, const ::proto::HealthCheckRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCheckHealth(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::proto::HealthCheckRequest,::proto::Payload>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_UploadFile<WithStreamedUnaryMethod_CheckHealth<Service > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_UploadFile<WithStreamedUnaryMethod_CheckHealth<Service > > StreamedService;
};

class ProjectionDatastoreService final {
 public:
  static constexpr char const* service_full_name() {
    return "proto.ProjectionDatastoreService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status UploadProjection(::grpc::ClientContext* context, const ::proto::UploadProjectionRequest& request, ::proto::Payload* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>> AsyncUploadProjection(::grpc::ClientContext* context, const ::proto::UploadProjectionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>>(AsyncUploadProjectionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>> PrepareAsyncUploadProjection(::grpc::ClientContext* context, const ::proto::UploadProjectionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>>(PrepareAsyncUploadProjectionRaw(context, request, cq));
    }
    virtual ::grpc::Status AppendProjection(::grpc::ClientContext* context, const ::proto::AppendProjectionRequest& request, ::proto::Payload* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>> AsyncAppendProjection(::grpc::ClientContext* context, const ::proto::AppendProjectionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>>(AsyncAppendProjectionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>> PrepareAsyncAppendProjection(::grpc::ClientContext* context, const ::proto::AppendProjectionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>>(PrepareAsyncAppendProjectionRaw(context, request, cq));
    }
    virtual ::grpc::Status DownloadProjection(::grpc::ClientContext* context, const ::proto::DownloadProjectionRequest& request, ::proto::DownloadProjectionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::DownloadProjectionResponse>> AsyncDownloadProjection(::grpc::ClientContext* context, const ::proto::DownloadProjectionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::DownloadProjectionResponse>>(AsyncDownloadProjectionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::DownloadProjectionResponse>> PrepareAsyncDownloadProjection(::grpc::ClientContext* context, const ::proto::DownloadProjectionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::DownloadProjectionResponse>>(PrepareAsyncDownloadProjectionRaw(context, request, cq));
    }
    virtual ::grpc::Status DownloadMovieIndices(::grpc::ClientContext* context, const ::proto::DownloadMovieIndicesRequest& request, ::proto::DownloadMovieIndicesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::DownloadMovieIndicesResponse>> AsyncDownloadMovieIndices(::grpc::ClientContext* context, const ::proto::DownloadMovieIndicesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::DownloadMovieIndicesResponse>>(AsyncDownloadMovieIndicesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::DownloadMovieIndicesResponse>> PrepareAsyncDownloadMovieIndices(::grpc::ClientContext* context, const ::proto::DownloadMovieIndicesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::DownloadMovieIndicesResponse>>(PrepareAsyncDownloadMovieIndicesRaw(context, request, cq));
    }
    virtual ::grpc::Status ShardCount(::grpc::ClientContext* context, const ::proto::ShardCountRequest& request, ::proto::ShardCountResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::ShardCountResponse>> AsyncShardCount(::grpc::ClientContext* context, const ::proto::ShardCountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::ShardCountResponse>>(AsyncShardCountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::ShardCountResponse>> PrepareAsyncShardCount(::grpc::ClientContext* context, const ::proto::ShardCountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::ShardCountResponse>>(PrepareAsyncShardCountRaw(context, request, cq));
    }
    virtual ::grpc::Status CheckHealth(::grpc::ClientContext* context, const ::proto::HealthCheckRequest& request, ::proto::Payload* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>> AsyncCheckHealth(::grpc::ClientContext* context, const ::proto::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>>(AsyncCheckHealthRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>> PrepareAsyncCheckHealth(::grpc::ClientContext* context, const ::proto::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>>(PrepareAsyncCheckHealthRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void UploadProjection(::grpc::ClientContext* context, const ::proto::UploadProjectionRequest* request, ::proto::Payload* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UploadProjection(::grpc::ClientContext* context, const ::proto::UploadProjectionRequest* request, ::proto::Payload* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void AppendProjection(::grpc::ClientContext* context, const ::proto::AppendProjectionRequest* request, ::proto::Payload* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AppendProjection(::grpc::ClientContext* context, const ::proto::AppendProjectionRequest* request, ::proto::Payload* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void DownloadProjection(::grpc::ClientContext* context, const ::proto::DownloadProjectionRequest* request, ::proto::DownloadProjectionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DownloadProjection(::grpc::ClientContext* context, const ::proto::DownloadProjectionRequest* request, ::proto::DownloadProjectionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void DownloadMovieIndices(::grpc::ClientContext* context, const ::proto::DownloadMovieIndicesRequest* request, ::proto::DownloadMovieIndicesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DownloadMovieIndices(::grpc::ClientContext* context, const ::proto::DownloadMovieIndicesRequest* request, ::proto::DownloadMovieIndicesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void ShardCount(::grpc::ClientContext* context, const ::proto::ShardCountRequest* request, ::proto::ShardCountResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ShardCount(::grpc::ClientContext* context, const ::proto::ShardCountRequest* request, ::proto::ShardCountResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void CheckHealth(::grpc::ClientContext* context, const ::proto::HealthCheckRequest* request, ::proto::Payload* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CheckHealth(::grpc::ClientContext* context, const ::proto::HealthCheckRequest* request, ::proto::Payload* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>* AsyncUploadProjectionRaw(::grpc::ClientContext* context, const ::proto::UploadProjectionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>* PrepareAsyncUploadProjectionRaw(::grpc::ClientContext* context, const ::proto::UploadProjectionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>* AsyncAppendProjectionRaw(::grpc::ClientContext* context, const ::proto::AppendProjectionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>* PrepareAsyncAppendProjectionRaw(::grpc::ClientContext* context, const ::proto::AppendProjectionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::DownloadProjectionResponse>* AsyncDownloadProjectionRaw(::grpc::ClientContext* context, const ::proto::DownloadProjectionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::DownloadProjectionResponse>* PrepareAsyncDownloadProjectionRaw(::grpc::ClientContext* context, const ::proto::DownloadProjectionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::DownloadMovieIndicesResponse>* AsyncDownloadMovieIndicesRaw(::grpc::ClientContext* context, const ::proto::DownloadMovieIndicesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::DownloadMovieIndicesResponse>* PrepareAsyncDownloadMovieIndicesRaw(::grpc::ClientContext* context, const ::proto::DownloadMovieIndicesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::ShardCountResponse>* AsyncShardCountRaw(::grpc::ClientContext* context, const ::proto::ShardCountRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::ShardCountResponse>* PrepareAsyncShardCountRaw(::grpc::ClientContext* context, const ::proto::ShardCountRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>* AsyncCheckHealthRaw(::grpc::ClientContext* context, const ::proto::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::Payload>* PrepareAsyncCheckHealthRaw(::grpc::ClientContext* context, const ::proto::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status UploadProjection(::grpc::ClientContext* context, const ::proto::UploadProjectionRequest& request, ::proto::Payload* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>> AsyncUploadProjection(::grpc::ClientContext* context, const ::proto::UploadProjectionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>>(AsyncUploadProjectionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>> PrepareAsyncUploadProjection(::grpc::ClientContext* context, const ::proto::UploadProjectionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>>(PrepareAsyncUploadProjectionRaw(context, request, cq));
    }
    ::grpc::Status AppendProjection(::grpc::ClientContext* context, const ::proto::AppendProjectionRequest& request, ::proto::Payload* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>> AsyncAppendProjection(::grpc::ClientContext* context, const ::proto::AppendProjectionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>>(AsyncAppendProjectionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>> PrepareAsyncAppendProjection(::grpc::ClientContext* context, const ::proto::AppendProjectionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>>(PrepareAsyncAppendProjectionRaw(context, request, cq));
    }
    ::grpc::Status DownloadProjection(::grpc::ClientContext* context, const ::proto::DownloadProjectionRequest& request, ::proto::DownloadProjectionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::DownloadProjectionResponse>> AsyncDownloadProjection(::grpc::ClientContext* context, const ::proto::DownloadProjectionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::DownloadProjectionResponse>>(AsyncDownloadProjectionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::DownloadProjectionResponse>> PrepareAsyncDownloadProjection(::grpc::ClientContext* context, const ::proto::DownloadProjectionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::DownloadProjectionResponse>>(PrepareAsyncDownloadProjectionRaw(context, request, cq));
    }
    ::grpc::Status DownloadMovieIndices(::grpc::ClientContext* context, const ::proto::DownloadMovieIndicesRequest& request, ::proto::DownloadMovieIndicesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::DownloadMovieIndicesResponse>> AsyncDownloadMovieIndices(::grpc::ClientContext* context, const ::proto::DownloadMovieIndicesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::DownloadMovieIndicesResponse>>(AsyncDownloadMovieIndicesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::DownloadMovieIndicesResponse>> PrepareAsyncDownloadMovieIndices(::grpc::ClientContext* context, const ::proto::DownloadMovieIndicesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::DownloadMovieIndicesResponse>>(PrepareAsyncDownloadMovieIndicesRaw(context, request, cq));
    }
    ::grpc::Status ShardCount(::grpc::ClientContext* context, const ::proto::ShardCountRequest& request, ::proto::ShardCountResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::ShardCountResponse>> AsyncShardCount(::grpc::ClientContext* context, const ::proto::ShardCountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::ShardCountResponse>>(AsyncShardCountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::ShardCountResponse>> PrepareAsyncShardCount(::grpc::ClientContext* context, const ::proto::ShardCountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::ShardCountResponse>>(PrepareAsyncShardCountRaw(context, request, cq));
    }
    ::grpc::Status CheckHealth(::grpc::ClientContext* context, const ::proto::HealthCheckRequest& request, ::proto::Payload* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>> AsyncCheckHealth(::grpc::ClientContext* context, const ::proto::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>>(AsyncCheckHealthRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>> PrepareAsyncCheckHealth(::grpc::ClientContext* context, const ::proto::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::Payload>>(PrepareAsyncCheckHealthRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void UploadProjection(::grpc::ClientContext* context, const ::proto::UploadProjectionRequest* request, ::proto::Payload* response, std::function<void(::grpc::Status)>) override;
      void UploadProjection(::grpc::ClientContext* context, const ::proto::UploadProjectionRequest* request, ::proto::Payload* response, ::grpc::ClientUnaryReactor* reactor) override;
      void AppendProjection(::grpc::ClientContext* context, const ::proto::AppendProjectionRequest* request, ::proto::Payload* response, std::function<void(::grpc::Status)>) override;
      void AppendProjection(::grpc::ClientContext* context, const ::proto::AppendProjectionRequest* request, ::proto::Payload* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DownloadProjection(::grpc::ClientContext* context, const ::proto::DownloadProjectionRequest* request, ::proto::DownloadProjectionResponse* response, std::function<void(::grpc::Status)>) override;
      void DownloadProjection(::grpc::ClientContext* context, const ::proto::DownloadProjectionRequest* request, ::proto::DownloadProjectionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DownloadMovieIndices(::grpc::ClientContext* context, const ::proto::DownloadMovieIndicesRequest* request, ::proto::DownloadMovieIndicesResponse* response, std::function<void(::grpc::Status)>) override;
      void DownloadMovieIndices(::grpc::ClientContext* context, const ::proto::DownloadMovieIndicesRequest* request, ::proto::DownloadMovieIndicesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ShardCount(::grpc::ClientContext* context, const ::proto::ShardCountRequest* request, ::proto::ShardCountResponse* response, std::function<void(::grpc::Status)>) override;
      void ShardCount(::grpc::ClientContext* context, const ::proto::ShardCountRequest* request, ::proto::ShardCountResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CheckHealth(::grpc::ClientContext* context, const ::proto::HealthCheckRequest* request, ::proto::Payload* response, std::function<void(::grpc::Status)>) override;
      void CheckHealth(::grpc::ClientContext* context, const ::proto::HealthCheckRequest* request, ::proto::Payload* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::proto::Payload>* AsyncUploadProjectionRaw(::grpc::ClientContext* context, const ::proto::UploadProjectionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::Payload>* PrepareAsyncUploadProjectionRaw(::grpc::ClientContext* context, const ::proto::UploadProjectionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::Payload>* AsyncAppendProjectionRaw(::grpc::ClientContext* context, const ::proto::AppendProjectionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::Payload>* PrepareAsyncAppendProjectionRaw(::grpc::ClientContext* context, const ::proto::AppendProjectionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::DownloadProjectionResponse>* AsyncDownloadProjectionRaw(::grpc::ClientContext* context, const ::proto::DownloadProjectionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::DownloadProjectionResponse>* PrepareAsyncDownloadProjectionRaw(::grpc::ClientContext* context, const ::proto::DownloadProjectionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::DownloadMovieIndicesResponse>* AsyncDownloadMovieIndicesRaw(::grpc::ClientContext* context, const ::proto::DownloadMovieIndicesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::DownloadMovieIndicesResponse>* PrepareAsyncDownloadMovieIndicesRaw(::grpc::ClientContext* context, const ::proto::DownloadMovieIndicesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::ShardCountResponse>* AsyncShardCountRaw(::grpc::ClientContext* context, const ::proto::ShardCountRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::ShardCountResponse>* PrepareAsyncShardCountRaw(::grpc::ClientContext* context, const ::proto::ShardCountRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::Payload>* AsyncCheckHealthRaw(::grpc::ClientContext* context, const ::proto::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::Payload>* PrepareAsyncCheckHealthRaw(::grpc::ClientContext* context, const ::proto::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_UploadProjection_;
    const ::grpc::internal::RpcMethod rpcmethod_AppendProjection_;
    const ::grpc::internal::RpcMethod rpcmethod_DownloadProjection_;
    const ::grpc::internal::RpcMethod rpcmethod_DownloadMovieIndices_;
    const ::grpc::internal::RpcMethod rpcmethod_ShardCount_;
    const ::grpc::internal::RpcMethod rpcmethod_CheckHealth_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status UploadProjection(::grpc::ServerContext* context, const ::proto::UploadProjectionRequest* request, ::proto::Payload* response);
    virtual ::grpc::Status AppendProjection(::grpc::ServerContext* context, const ::proto::AppendProjectionRequest* request, ::proto::Payload* response);
    virtual ::grpc::Status DownloadProjection(::grpc::ServerContext* context, const ::proto::DownloadProjectionRequest* request, ::proto::DownloadProjectionResponse* response);
    virtual ::grpc::Status DownloadMovieIndices(::grpc::ServerContext* context, const ::proto::DownloadMovieIndicesRequest* request, ::proto::DownloadMovieIndicesResponse* response);
    virtual ::grpc::Status ShardCount(::grpc::ServerContext* context, const ::proto::ShardCountRequest* request, ::proto::ShardCountResponse* response);
    virtual ::grpc::Status CheckHealth(::grpc::ServerContext* context, const ::proto::HealthCheckRequest* request, ::proto::Payload* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_UploadProjection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UploadProjection() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_UploadProjection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadProjection(::grpc::ServerContext* /*context*/, const ::proto::UploadProjectionRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUploadProjection(::grpc::ServerContext* context, ::proto::UploadProjectionRequest* request, ::grpc::ServerAsyncResponseWriter< ::proto::Payload>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AppendProjection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AppendProjection() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_AppendProjection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AppendProjection(::grpc::ServerContext* /*context*/, const ::proto::AppendProjectionRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAppendProjection(::grpc::ServerContext* context, ::proto::AppendProjectionRequest* request, ::grpc::ServerAsyncResponseWriter< ::proto::Payload>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DownloadProjection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DownloadProjection() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_DownloadProjection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadProjection(::grpc::ServerContext* /*context*/, const ::proto::DownloadProjectionRequest* /*request*/, ::proto::DownloadProjectionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDownloadProjection(::grpc::ServerContext* context, ::proto::DownloadProjectionRequest* request, ::grpc::ServerAsyncResponseWriter< ::proto::DownloadProjectionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DownloadMovieIndices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DownloadMovieIndices() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_DownloadMovieIndices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadMovieIndices(::grpc::ServerContext* /*context*/, const ::proto::DownloadMovieIndicesRequest* /*request*/, ::proto::DownloadMovieIndicesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDownloadMovieIndices(::grpc::ServerContext* context, ::proto::DownloadMovieIndicesRequest* request, ::grpc::ServerAsyncResponseWriter< ::proto::DownloadMovieIndicesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ShardCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ShardCount() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_ShardCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ShardCount(::grpc::ServerContext* /*context*/, const ::proto::ShardCountRequest* /*request*/, ::proto::ShardCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestShardCount(::grpc::ServerContext* context, ::proto::ShardCountRequest* request, ::grpc::ServerAsyncResponseWriter< ::proto::ShardCountResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CheckHealth : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CheckHealth() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_CheckHealth() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckHealth(::grpc::ServerContext* /*context*/, const ::proto::HealthCheckRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheckHealth(::grpc::ServerContext* context, ::proto::HealthCheckRequest* request, ::grpc::ServerAsyncResponseWriter< ::proto::Payload>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_UploadProjection<WithAsyncMethod_AppendProjection<WithAsyncMethod_DownloadProjection<WithAsyncMethod_DownloadMovieIndices<WithAsyncMethod_ShardCount<WithAsyncMethod_CheckHealth<Service > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_UploadProjection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_UploadProjection() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::proto::UploadProjectionRequest, ::proto::Payload>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::proto::UploadProjectionRequest* request, ::proto::Payload* response) { return this->UploadProjection(context, request, response); }));}
    void SetMessageAllocatorFor_UploadProjection(
        ::grpc::MessageAllocator< ::proto::UploadProjectionRequest, ::proto::Payload>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::proto::UploadProjectionRequest, ::proto::Payload>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_UploadProjection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadProjection(::grpc::ServerContext* /*context*/, const ::proto::UploadProjectionRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UploadProjection(
      ::grpc::CallbackServerContext* /*context*/, const ::proto::UploadProjectionRequest* /*request*/, ::proto::Payload* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_AppendProjection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_AppendProjection() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::proto::AppendProjectionRequest, ::proto::Payload>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::proto::AppendProjectionRequest* request, ::proto::Payload* response) { return this->AppendProjection(context, request, response); }));}
    void SetMessageAllocatorFor_AppendProjection(
        ::grpc::MessageAllocator< ::proto::AppendProjectionRequest, ::proto::Payload>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::proto::AppendProjectionRequest, ::proto::Payload>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_AppendProjection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AppendProjection(::grpc::ServerContext* /*context*/, const ::proto::AppendProjectionRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AppendProjection(
      ::grpc::CallbackServerContext* /*context*/, const ::proto::AppendProjectionRequest* /*request*/, ::proto::Payload* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DownloadProjection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DownloadProjection() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::proto::DownloadProjectionRequest, ::proto::DownloadProjectionResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::proto::DownloadProjectionRequest* request, ::proto::DownloadProjectionResponse* response) { return this->DownloadProjection(context, request, response); }));}
    void SetMessageAllocatorFor_DownloadProjection(
        ::grpc::MessageAllocator< ::proto::DownloadProjectionRequest, ::proto::DownloadProjectionResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::proto::DownloadProjectionRequest, ::proto::DownloadProjectionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DownloadProjection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadProjection(::grpc::ServerContext* /*context*/, const ::proto::DownloadProjectionRequest* /*request*/, ::proto::DownloadProjectionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DownloadProjection(
      ::grpc::CallbackServerContext* /*context*/, const ::proto::DownloadProjectionRequest* /*request*/, ::proto::DownloadProjectionResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DownloadMovieIndices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DownloadMovieIndices() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::proto::DownloadMovieIndicesRequest, ::proto::DownloadMovieIndicesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::proto::DownloadMovieIndicesRequest* request, ::proto::DownloadMovieIndicesResponse* response) { return this->DownloadMovieIndices(context, request, response); }));}
    void SetMessageAllocatorFor_DownloadMovieIndices(
        ::grpc::MessageAllocator< ::proto::DownloadMovieIndicesRequest, ::proto::DownloadMovieIndicesResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::proto::DownloadMovieIndicesRequest, ::proto::DownloadMovieIndicesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DownloadMovieIndices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadMovieIndices(::grpc::ServerContext* /*context*/, const ::proto::DownloadMovieIndicesRequest* /*request*/, ::proto::DownloadMovieIndicesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DownloadMovieIndices(
      ::grpc::CallbackServerContext* /*context*/, const ::proto::DownloadMovieIndicesRequest* /*request*/, ::proto::DownloadMovieIndicesResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ShardCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ShardCount() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::proto::ShardCountRequest, ::proto::ShardCountResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::proto::ShardCountRequest* request, ::proto::ShardCountResponse* response) { return this->ShardCount(context, request, response); }));}
    void SetMessageAllocatorFor_ShardCount(
        ::grpc::MessageAllocator< ::proto::ShardCountRequest, ::proto::ShardCountResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::proto::ShardCountRequest, ::proto::ShardCountResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ShardCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ShardCount(::grpc::ServerContext* /*context*/, const ::proto::ShardCountRequest* /*request*/, ::proto::ShardCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ShardCount(
      ::grpc::CallbackServerContext* /*context*/, const ::proto::ShardCountRequest* /*request*/, ::proto::ShardCountResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CheckHealth : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CheckHealth() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::proto::HealthCheckRequest, ::proto::Payload>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::proto::HealthCheckRequest* request, ::proto::Payload* response) { return this->CheckHealth(context, request, response); }));}
    void SetMessageAllocatorFor_CheckHealth(
        ::grpc::MessageAllocator< ::proto::HealthCheckRequest, ::proto::Payload>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::proto::HealthCheckRequest, ::proto::Payload>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CheckHealth() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckHealth(::grpc::ServerContext* /*context*/, const ::proto::HealthCheckRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CheckHealth(
      ::grpc::CallbackServerContext* /*context*/, const ::proto::HealthCheckRequest* /*request*/, ::proto::Payload* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_UploadProjection<WithCallbackMethod_AppendProjection<WithCallbackMethod_DownloadProjection<WithCallbackMethod_DownloadMovieIndices<WithCallbackMethod_ShardCount<WithCallbackMethod_CheckHealth<Service > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_UploadProjection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UploadProjection() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_UploadProjection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadProjection(::grpc::ServerContext* /*context*/, const ::proto::UploadProjectionRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AppendProjection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AppendProjection() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_AppendProjection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AppendProjection(::grpc::ServerContext* /*context*/, const ::proto::AppendProjectionRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DownloadProjection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DownloadProjection() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_DownloadProjection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadProjection(::grpc::ServerContext* /*context*/, const ::proto::DownloadProjectionRequest* /*request*/, ::proto::DownloadProjectionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DownloadMovieIndices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DownloadMovieIndices() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_DownloadMovieIndices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadMovieIndices(::grpc::ServerContext* /*context*/, const ::proto::DownloadMovieIndicesRequest* /*request*/, ::proto::DownloadMovieIndicesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ShardCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ShardCount() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_ShardCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ShardCount(::grpc::ServerContext* /*context*/, const ::proto::ShardCountRequest* /*request*/, ::proto::ShardCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CheckHealth : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CheckHealth() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_CheckHealth() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckHealth(::grpc::ServerContext* /*context*/, const ::proto::HealthCheckRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_UploadProjection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UploadProjection() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_UploadProjection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadProjection(::grpc::ServerContext* /*context*/, const ::proto::UploadProjectionRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUploadProjection(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AppendProjection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AppendProjection() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_AppendProjection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AppendProjection(::grpc::ServerContext* /*context*/, const ::proto::AppendProjectionRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAppendProjection(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DownloadProjection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DownloadProjection() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_DownloadProjection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadProjection(::grpc::ServerContext* /*context*/, const ::proto::DownloadProjectionRequest* /*request*/, ::proto::DownloadProjectionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDownloadProjection(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DownloadMovieIndices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DownloadMovieIndices() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_DownloadMovieIndices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadMovieIndices(::grpc::ServerContext* /*context*/, const ::proto::DownloadMovieIndicesRequest* /*request*/, ::proto::DownloadMovieIndicesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDownloadMovieIndices(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ShardCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ShardCount() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_ShardCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ShardCount(::grpc::ServerContext* /*context*/, const ::proto::ShardCountRequest* /*request*/, ::proto::ShardCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestShardCount(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CheckHealth : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CheckHealth() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_CheckHealth() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckHealth(::grpc::ServerContext* /*context*/, const ::proto::HealthCheckRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheckHealth(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_UploadProjection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_UploadProjection() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UploadProjection(context, request, response); }));
    }
    ~WithRawCallbackMethod_UploadProjection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadProjection(::grpc::ServerContext* /*context*/, const ::proto::UploadProjectionRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UploadProjection(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_AppendProjection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_AppendProjection() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AppendProjection(context, request, response); }));
    }
    ~WithRawCallbackMethod_AppendProjection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AppendProjection(::grpc::ServerContext* /*context*/, const ::proto::AppendProjectionRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AppendProjection(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DownloadProjection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DownloadProjection() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DownloadProjection(context, request, response); }));
    }
    ~WithRawCallbackMethod_DownloadProjection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadProjection(::grpc::ServerContext* /*context*/, const ::proto::DownloadProjectionRequest* /*request*/, ::proto::DownloadProjectionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DownloadProjection(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DownloadMovieIndices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DownloadMovieIndices() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DownloadMovieIndices(context, request, response); }));
    }
    ~WithRawCallbackMethod_DownloadMovieIndices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadMovieIndices(::grpc::ServerContext* /*context*/, const ::proto::DownloadMovieIndicesRequest* /*request*/, ::proto::DownloadMovieIndicesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DownloadMovieIndices(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ShardCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ShardCount() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ShardCount(context, request, response); }));
    }
    ~WithRawCallbackMethod_ShardCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ShardCount(::grpc::ServerContext* /*context*/, const ::proto::ShardCountRequest* /*request*/, ::proto::ShardCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ShardCount(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CheckHealth : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CheckHealth() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CheckHealth(context, request, response); }));
    }
    ~WithRawCallbackMethod_CheckHealth() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckHealth(::grpc::ServerContext* /*context*/, const ::proto::HealthCheckRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CheckHealth(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UploadProjection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UploadProjection() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::proto::UploadProjectionRequest, ::proto::Payload>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::proto::UploadProjectionRequest, ::proto::Payload>* streamer) {
                       return this->StreamedUploadProjection(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UploadProjection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UploadProjection(::grpc::ServerContext* /*context*/, const ::proto::UploadProjectionRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUploadProjection(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::proto::UploadProjectionRequest,::proto::Payload>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AppendProjection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AppendProjection() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::proto::AppendProjectionRequest, ::proto::Payload>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::proto::AppendProjectionRequest, ::proto::Payload>* streamer) {
                       return this->StreamedAppendProjection(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AppendProjection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AppendProjection(::grpc::ServerContext* /*context*/, const ::proto::AppendProjectionRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAppendProjection(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::proto::AppendProjectionRequest,::proto::Payload>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DownloadProjection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DownloadProjection() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::proto::DownloadProjectionRequest, ::proto::DownloadProjectionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::proto::DownloadProjectionRequest, ::proto::DownloadProjectionResponse>* streamer) {
                       return this->StreamedDownloadProjection(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DownloadProjection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DownloadProjection(::grpc::ServerContext* /*context*/, const ::proto::DownloadProjectionRequest* /*request*/, ::proto::DownloadProjectionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDownloadProjection(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::proto::DownloadProjectionRequest,::proto::DownloadProjectionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DownloadMovieIndices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DownloadMovieIndices() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::proto::DownloadMovieIndicesRequest, ::proto::DownloadMovieIndicesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::proto::DownloadMovieIndicesRequest, ::proto::DownloadMovieIndicesResponse>* streamer) {
                       return this->StreamedDownloadMovieIndices(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DownloadMovieIndices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DownloadMovieIndices(::grpc::ServerContext* /*context*/, const ::proto::DownloadMovieIndicesRequest* /*request*/, ::proto::DownloadMovieIndicesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDownloadMovieIndices(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::proto::DownloadMovieIndicesRequest,::proto::DownloadMovieIndicesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ShardCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ShardCount() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::proto::ShardCountRequest, ::proto::ShardCountResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::proto::ShardCountRequest, ::proto::ShardCountResponse>* streamer) {
                       return this->StreamedShardCount(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ShardCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ShardCount(::grpc::ServerContext* /*context*/, const ::proto::ShardCountRequest* /*request*/, ::proto::ShardCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedShardCount(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::proto::ShardCountRequest,::proto::ShardCountResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CheckHealth : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CheckHealth() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::proto::HealthCheckRequest, ::proto::Payload>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::proto::HealthCheckRequest, ::proto::Payload>* streamer) {
                       return this->StreamedCheckHealth(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CheckHealth() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CheckHealth(::grpc::ServerContext* /*context*/, const ::proto::HealthCheckRequest* /*request*/, ::proto::Payload* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCheckHealth(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::proto::HealthCheckRequest,::proto::Payload>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_UploadProjection<WithStreamedUnaryMethod_AppendProjection<WithStreamedUnaryMethod_DownloadProjection<WithStreamedUnaryMethod_DownloadMovieIndices<WithStreamedUnaryMethod_ShardCount<WithStreamedUnaryMethod_CheckHealth<Service > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_UploadProjection<WithStreamedUnaryMethod_AppendProjection<WithStreamedUnaryMethod_DownloadProjection<WithStreamedUnaryMethod_DownloadMovieIndices<WithStreamedUnaryMethod_ShardCount<WithStreamedUnaryMethod_CheckHealth<Service > > > > > > StreamedService;
};

}  // namespace proto


#endif  // GRPC_resource_5fservices_2eproto__INCLUDED
